+++
date = '2025-12-09T14:21:03+08:00'
title = 'RN基础之壹'
readingTime = true
description = '记录自己学习RN的基础组件'
categories = [
    "跨端",
    "RN",
]
tags = [
    "Android",
    "RN",
]
image="RN基础.png"
+++

# React Native 核心基础篇

>   本篇博客搬运 **极客时间 蒋宏伟 老师的课程** [原文点我](https://time.geekbang.org/column/intro/100110101?code=FAqHFVRUur%25252FgAP-yJQWitk9ieF80imRky3PVsIs%25252FX6A%25253D&tab=catalog) 侵权联系网站博主删除。

## 01｜学习React Native，你需要掌握哪些知识？

### 基础知识

那所谓的基础知识是什么呢？我认为能够满足开发业务的最小知识集合都是基础。比如，语言、框架和一些编程的必备工具，还有 React Native 框架和社区提供的核心组件、核心 API，再有就是熟悉工作流包括搭建环境、开发流程、上线流程，这些都是 React Native 的基础知识。

不过，每个人的技术背景不一样、工作年限也不一样，新手可能对大部分的基础知识都不太熟悉。而已经有过多年 React Native 开发经验的老手，对有些基础知识的使用方法都已经掌握得差不多了，千人千面。

但我认为，无论是新手还是老手，你都应该系统地、有深度地再学习一遍，把基础打扎实了。我相信，核心基础篇能给你带来更深刻、更系统的认知。

在广度上，为了能让你对基础知识有个系统的了解，我为你准备了一张知识地图。即便有些知识，我们没有进行深层的讲解，你也可以根据知识地图和补充材料中的提示，自己搜索。

![RN基础图](RN-jichu-tu1.png)

其中，蓝色背景和蓝色文字的内容就是我们专栏核心基础篇中的重点内容，那些灰色背景、灰色文字的内容就是你需要自己学习和掌握的基础知识。如果灰色部分中有不是很了解的知识点，你可以根据知识地图自学一下，遇到了任何问题，都欢迎你给我留言。

可以看到，在这张知识地图中，我把知识分为了三类。

-   第一类是开发语言、React 框架、开发必备工具这些预备知识。虽然这些预备知识，并不是 React Native 本身的重点内容，但这些都是你在开发之前需要掌握的。如果你对 JavaScript 不了解，你可以参考 [MDN JS 教程](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Language_overview) 自行学下一下，其中 [npm](https://www.7-zip.cn/) 等工具使用起来会比较简单，你可以参考 npm 中文文档 自行摸索学习。但考虑到有些小伙伴对 React 可能没有那么熟悉，所以这方面的预备知识，我还会用三讲的内容进行讲解。
-   第二类知识是 React Native 本身的知识。组件是这类知识中的重点，包括框架提供的组件和社区提供的组件，这方面我会重点讲解。但 API 类的知识，本身比较简单，所以我只挑选了样式内容和你进行讲解。至于其他 API 知识，你在用的时候，查查 [React Native 官方文档](https://reactnative.cn/)就能很快学会了。
-   第三类知识是工作流中的实操知识。学习实操类知识最好的方法，其实是根据手册一步一步操作，所以这一块我不会细讲。但其中有些能帮你节约自己独立探索时间的经验类的知识，比如 UI 开发技巧和逻辑调试思路，我也会和你分享。

### 第一部分：React 框架

我们刚才说，学习 React Native 要掌握的第一类知识，包含了 React 框架。众所周知，React Native 是一个基于 React 的原生应用框架。那学习 React 最关键的就是，理解 React 是一个**基于组件的、声明式的 UI 框架**，我把这句话拆开和你解释。

1.   先来看 React 的第一个特点：**基于组件（Component-Based）**。

     最开始 React 只能用来写 Web 应用，它是在 2013 年正式开始开源的。在此之前，业内的大多数 Web 框架都是 MVC 框架。 MVC 框架解决了代码大杂烩的问题，它把代码分成了职责分明的三层，M 指的是数据模型 Modal，V 指的视图模板 View，C 指的是控制器 Controller。MVC 强调的是数据、视图和逻辑之间松耦合，其文件结构也是按这三类分门别类地组织起来的。

     但 React 不一样，React 强调的是组件的可组合型。在 React 中，颗粒度最小的是浏览器提供的 HTML 标签，或者是 React Native 框架提供的组件。这些颗粒度最小的基础标签、基础组件可以相互嵌套、拼装成一个颗粒度稍大一些的自定义组件。小的自定义组件可以拼装成大的自定义组件，大的自定义组件又可以拼装成页面和应用。

     从代码大杂烩，到 MCV 三层架构，再到 React 的自定义组件，代码组织形式经历很大的变化。React 基于组件的代码组织形式，也经历住了时间的考验，证明了它的优秀。

     React Native 应用也继承了“基于组件的”特性，它可以让我们将一个大的 UI 页面，拆分成若干个颗粒度更小的自定义组件，这能让我们的应用更容易扩展和维护。

2.   接着我们再来看 React 的第二个特点：**声明式（Declarative）**。

     声明式是什么呢？所谓的“声明式的”就是，你只需要告诉程序“做什么”（What），程序会自动帮你解决“怎么做”（How）的问题，这让我们创建复杂的交互应用变得轻而易举。

     你使用过的 HTML 也算一种“声明式”的语言。不同的是， HTML 功能太简单了，而且它也不是图灵完备的语言。但 React 不一样，它使用的是 JavaScript 来描述 UI 页面的结构，并且在 JavaScript 中创建了一种类似 HTML 的方言，也就是 JSX 语法扩展。

     JSX 语法既保留了 JavaScript 的灵活、强大和图灵完备特性，也保留了 HTML 这类“声明式”语言易写、易读的特点。

     还值得多说一句的是，“声明式”是一种编程范式，它与“命令式”编程范式相对立的，它们之间是“是什么”（What）和“怎么做”（How）的对立关系。“命令式”就好像你自己开车，你得自己控制方向盘。而“声明式”就好像完全自动驾驶的汽车，你告诉它要去哪儿，它就会自己开到哪。

     声明式编程是一个大的概念，除了我们前面提到了 HTML 所属的领域专属语言（DSL）之外，还有函数式编程等子编程范式。熟悉 React 的同学可能就知道了，React 借鉴了大量的函数式编程的思想。核心基础篇中的函数组件、hook，还有我们后面要讲的状态管理工具 Redux 和新架构原理，都大量使用了函数式编程的思想。

好了，现在你知道了，React Native 的基础是 React，而 React 又是一个基于组件的、声明式的 UI 框架，因此后面我会花两讲的内容和你介绍，这两个特点背后的基础知识：组件 Component 和状态 State。

### 第二部分：核心组件和样式

第二类你需要掌握的基础知识是 React Native 的核心组件和样式。

先说样式。样式决定了页面的“颜值”，它可以控制组件的颜色、字形、排列、大小，等等。有意思的是，Web 中的 CSS 是一门博大精深的学问，要学很久，但 React Native 中的样式内容却很少，它核心声明文件也就 600 多行代码。而且根据我的调研，大家也很少使用 React Native 样式工具、样式库来辅助开发，大部分时候使用默认的样式表 StyleSheet 的 “CSS In JS”写法就够用了。

那为什么 React Native 能用这么少的样式，来满足复杂的 UI 开发呢？

关键原因就是，React Native 的组件非常丰富，组件提供的属性满足了那些复杂“颜值”需求。比如，Web CSS 中的粘性定位 position:sticky，就可以用 React Native 中滚动组件 ScrollView 的粘性头部 StickyHeaderComponent 属性来满足，而且 React Native 的功能还更强大一些。

因此，我会花很大的篇幅和你重点讲讲 React Native 中的组件，包括图片组件 Image、点按组件 Pressable、输入组件 TextInput、列表组件 RecyclerListView。选择这 4 个组件来讲，不仅仅是因为它们用的频率高，**我们要学习它的使用方法，我们也要去研究它的原理，希望它们背后的设计思想能够为我所用**。

学习这 4 种组件，其实各有侧重。学习图片组件时，我们最应该关注的是**加载性能和开发的便捷性**应该如何取舍。比如，内置图片性能是好，但会增加包体积，而且加上容易删掉难；远程图片加载慢了点，但只需要管理远程地址，更新也是非常方便；又比如 Base64 会导致图片体积增加 1/4，但是它在热更新的情况下，能让图片第一时间展示出来。这些方案应该怎么选？又有没有自动化的、工程化的方法帮忙我们管理图片，进一步降低我们选择成本呢？

学习点按组件、输入组件时，我们最应该关注的是**交互体验**。点按按钮很简单，但做好交互体验这件事不简单。一个 App 的体验好不好，PM、UI、UX 设计得好与不好是一方面，但最终还是得靠工程师来实现。比如微信右上角的 + 号按钮，在屏幕上面不是那么好点，微信工程师就把它的可点击范围扩大了一些，让大家容易点中，这些都是值得我们学习的。

学习列表组件时，我们最应该关注的是**FPS 流畅度**，也就是滚动性能。React Native 老版本提供的 FlatList 的滚动性能不是很好，在低端机器上会有点卡，但是社区中提供了性能更好的 RecyclerListView，我们得学会用起来。

### 第三部分：实践经验和实战练习

然后，在项目实战练习之前，我还会和你讲讲有哪些高效开发 UI 的技巧，和调试疑难杂症的实践经验，帮你少走弯路。

核心基础篇的最后，就是项目的实战练习了。整个核心基础篇的目的，是希望能让你搭建一个简易的电商首页。我始终相信，只有实战才能将学到的知识变现为自己能力。

搭建一个电商首页，我们要解决两个问题。第一个问题是，现在电商首页大都是瀑布流形式的，在 React Native 如何实现一个高性能的瀑布流组件呢？社区中并没有现成答案，但是我们可以基于社区组件自己动手进行改造，我会带你一步一步实现一个高性能的瀑布流组件。

要解决的第二个问题是，搭建项目的最佳实践是什么？如果你是项目的负责人，你会怎么思考，来保障项目的可扩展性和可维护性？根据我的个人经验和业内的最佳实践，我总结出了一套适合我自己的方案，在《页面实战》这一讲中，我也会把它分享给你。

但我明白，你要把这些知识都学好，还得靠自己在实战中动手、摸索，因此我还会给你留作业，特别是 React Native 新手，请你一定要重视作业的重要性。

### 小结

好了，介绍到这里相信你已经知道学习 React Native 要掌握那些基础知识了，这些知识分为三类：

1.   React 类知识。React 是一个基于组件的、声明式的 UI 框架，而用好 React 的关键是用好自定义组件和状态，这也是你学好这门专栏必要的前提条件；
2.   React Native 本身的知识。这是核心基础篇的重点内容，它不仅包括 UI 怎么写、组件怎么用，你还去了解它们背后的原理，去提高页面的加载性能、交互体验、FPS 流畅度；
3.   实践类知识。这里主要是开发 UI 和调试代码的一些经验技巧，并且我也给你留了一个搭建简易电商网页的任务，我希望你以此实战为你学习核心基础篇的目标，同时也通过这个项目实战检验自己的学习成果，将知识内化为自己的能力。



## 02｜Component：搭建静态页面的正确思路是什么？

在工作中，特别是业务类的开发需求，绝大多数都是写页面。写页面分为两步，第一步是搭建静态页面，第二步是给静态页面添加交互让它动起来。这第一步至关重要，它决定了 UI 设计稿要拆分成哪些组件，这些组件又是如何组织起来的，这些都会影响程序的可扩展性和可维护性，甚至还有团队的合作方法。

我们这一讲的目的，就是让你有一个正确的基于组件搭建静态页面的思路，不让第一步走偏。要知道，如果后面再去纠正，要花费的成本就大了去了。

### 组件：可组合、可复用的“拆稿”方式

在开始使用组件这种方式构建静态页面之前，请你先思考一个问题，为什么 React/React Native 选择了基于组件的架构方式呢？

理论上，除了组件这种方式外，常见的构建应用方式还有：类似 HTML/CSS/JavaScript 这种的分层架构、基于 MVC 的分层架构。那为什么 React/React Native 没有选择这两种架构方式呢？

**这是因为，基于组件的架构模式，或许是现在重展示、重交互应用的最好选择。**

把 UI 设计稿拆成完全独立的 HTML/CSS/JavaScript 三个部分的这种架构已经不是主流了；2010 年开源的、代表 MVC 架构模式的 AngularJS 也被 Angular（v2 及更高版本）这种基于组件的架构模式所代替了；现在 iOS、Android 应用也有很多是基于组件开发的。

为什么会有这种现象呢？我先给你看一张架构对比图，你先可以体会一下它们之间的区别，找找原因：

<img src="RN-jichu-tu-2.png" style="zoom:50%;" />

现代应用都很复杂，而且非常重交互、重展示。如果 React Native 选择的是类似 HTML/CSS/JavaScript 的模板、样式、逻辑分离的分层架构，那可想而知，我们的三层代码都会非常臃肿。

如果 React Native 选择的是 MVC 架构，把逻辑控制、数据模型和视图进行分层，对程序横向分层纵向打通，这样代码颗粒度是会变小。但在重交互的前提下，层和层之间、列和列之间的数据流向却更复杂了。流动的方向不止是 MVC 架构图中画 “3+3” 的 6 个方向，而是层和层之间的 “332” 个方向，列和列之间的 “332” 个方向，非常复杂。

React/React Native 选择的是基于组件的架构模式，它有三个好处：

-   第一，组件是内聚的，组件内既有逻辑，又有状态，还有视图，一个组件可以独立完成一件事情，这也使得 UI 模块复用变得简单；
-   第二，组件之间是可以组合的，一个页面可以拆分成若干个大组件，大组件也可以拆分成小组件，当某个组件变大变臃肿时也可以进一步地拆分；
-   第三，组件和组件之间的数据流向永远是确定，永远是从上往下流动的，简单明了。

**组件可组合、可复用的特性，和组件之间单向数据流的模式**，在现代应用重交互重展示的情况下，显然更吃香，这也是 React/React Native 选择基于组件来构建应用的原因。

### 单一责任原则

现在我们回到第一步，基于组件搭建静态页面。

我们直接来看一个具体的例子。这里我放了一个简易商品列表页的 UI 设计稿，你可以先停下来思考一下，想一想你会把它拆成那些组件？你这么拆的原因又是什么？

<img src="RN-jichu-3.png" style="zoom:50%;" />

我们直接来揭晓答案，拆组件要准守一个原则，**单一责任原则**。

这也是 React 官方倡导的原则，这个原则的意思是**每个组件都应该只有一个单一的功能，并且这个组件和其他组件没有相互依赖**。当然，完全没有相互依赖是不可能的，但这种思路具有很高的指导价值，一个组件的依赖越少，设计得越好。

给你举个例子，一个组件你引用的依赖越多，这些依赖就像陌生的英语单词，你得去其他文件中去查词典，才能知道这些依赖的意思。依赖越多，越难读懂，也越难维护。

因此，为了可读性、可维护性、可测试性，就要减少组件的外部依赖，这就是单一责任原则的指导价值。

这样说来，在拆分简易商品列表页的 UI 设计稿时，我们就要尽可能地拆的更细一些，保证每个组件的责任单一，因为涉及到 UI 稿建议你打开文稿查看一下，那我们拆分结果如图所示：

<img src="rn-jichu-4.png" style="zoom:50%;" />

你可以看到，这个简易商品列表已经被拆分了 3 个组件，具体如下：

1.   ProductTable（紫色）：它是商品列表组件，显示商品列表和表头；
2.   Category（青色）：它是类别组件，显示一类商品的种类；
3.   Product（黄色）：它是商品组件，显示某个具体的商品名称和价格。

### 宿主组件：生产基础视图的工厂

当你有了怎么把 UI 设计稿拆分成组件的思路后，接下来就要构建静态页面了。

要构建静态页面，就要有基础的视图材料。在 React Native 中那些最基础、不可再拆的视图材料，大都是由 React Native 框架提供的**宿主视图**。

比如，UI 设计稿中的水果名称：“苹果”、“火龙果”，价格：“￥1”、“￥2”，还有最顶部的搜索框，这些都是宿主视图。

而生产宿主视图的工厂，就是宿主组件（Host Components）。这些**宿主组件通常是 React Native 框架提供的组件，它们和你用 JavaScript 自定义的组件不同，宿主组件是直接由 iOS/Android 原生平台实现的**。

除了 React Native 框架提供的宿主组件外，一些社区库也提供了宿主组件，甚至你自己也可以创建宿主组件。

它们共同的特点是，这些宿主组件上层是 JavaScript 部分，底层是 Native 部分，这两部分是通过 React Native 框架联系起来的。也就是说，你调用宿主组件时，底层直接渲染的是 Native 视图。

那么，我们这个简易商品列表页的 UI 设计稿中，用到了那些宿主组件呢？其实有三种：

-   容器组件 View：顾名思义它就是一个容器，可以用来包裹其他的组件，类似于 Web 中用于嵌套的 div；
-   文字组件 Text：设计稿中的文字，比如水果名字“苹果”、“梨子”，价格“1 元”、“3 元”等等，这些类似于 Web 中装载文字的 span。
-   安全区域组件 SafeAreaView：它是最外层的容器组件，用于适配 iPhoneX 等的刘海儿屏。

宿主组件就是一个生产基础视图的工厂，你可以用 Text 组件实例化不同的文字视图。比如，我们可以实例化一个“苹果”文字，也可以再实例化另一个“火龙果”文字，代码如下：

```jsx
import {Text} from 'react-native';
const element1 = 苹果 // JSX 
const element2 = 火龙果 // JSX
```

你看啊，在这段用 JavaScript 书写的代码中，使用了类似 HTML 的声明式语法，JSX。我们先从 react-native 框架中引入了 Text 组件，然后通过 JSX 语法，用一对单闭合标签将 Text 组件进行实例化，生成 Text 元素 element1。当 element1 这个元素渲染到手机屏幕上，就是文字“苹果”了，element2 就是文字“火龙果”。

### 复合组件：纯 JavaScript 函数

现在，你已经有了构建静态页面的宿主组件了，接下来你需要用这些宿主组件，搭建你自己事先拆好的自定义组件了，包括：

-   ProductTable 商品列表组件
-   Category 类别组件
-   Product 商品组件

要创建自定义的宿主组件，你必须写 Native 代码。但上面 3 个自定义组件，**你可以直接用 JavaScript 创建，不用写 Native 代码，这类组件也叫复合组件（Composite Components）**。这些复合组件是基于宿主组件或其他复合组件搭建而成的。

现在我们来创建第一个自定义的复合组件：Product 商品组件，它的示例代码如下：

```jsx
export default function Product({product = {name: '苹果', price: '1元'} }) {
  return (
    <View style={{flexDirection: 'row', marginTop: 5}}>
      <Text style={{flex: 1}}>{product.name}</Text>
      <Text style={{width: 50}}>{product.price}</Text>
    </View>
  );
}
```

这段代码，对于一些新手来说可能有点长，我分四步和你解释：

第一步，导出组件。还记得单一责任原则吗？一个组件的责任要单一，一个文件的责任也要单一。因此通常一个文件中只有一个组件，用export default就可以将它导出，让其他文件import引入使用。

第二步，定义函数。组件是一种特殊的函数。组件名字的首字母一定是大写的，示例中的`Product`是组件，因此它的`P`是大写的（当然，还有类组件，但用得会越来越少，这里我们不探讨，你可以自己额外搜些资料）。

第三步，接收入参。组件能从其父组件中接参数，而且组件是函数，因此该参数就是函数的入参，通常命名为属性 `props`。```props``` 是一个对象，因此也可以直接对它进行解构，直接获取对象中的值。

示例代码中用的就是用解构的方式来获取参数的，它直接获取了product参数，这里的product 是数据因此p是小写的。

第四步，返回 JSX。组件的返回值就是 JSX，我们前面也提到过，它是用来描述 UI 页面的，JSX 最终生成的是视图元素、文字元素。这里我们初始化了一个元素，和两个元素。

我们概括一下，自定义复合组件就是一个纯粹的 JavaScript 函数，**谁调用它，谁就可以给它传入参数，同样它调用谁，它就可以给谁传入参数**，而 JSX 闭合标签就是调用函数的语法糖。

### 静态页面的最终实现

现在你知道了 Product 商品组件如何定义，那么 Category 类别组件、ProductTable 商品列表组件对你来说，也就很容易了。

最后我们来看下，静态页的最终实现，完整代码有点长，我就不都贴出来了，你可以看看文末补充材料中的链接，现在我们只看下它整体长什么样子：

```jsx
// index.js
AppRegistry.registerComponent('appName', () => App);



// App.js
const PRODUCTS = [
  {category: '水果', price: '￥1', name: 'PingGuo'},
];

export default function App() {
  return (
    <SafeAreaView style={{marginHorizontal: 30}}>
      <ProductTable products={PRODUCTS} />
    </SafeAreaView>
  );
}

// ProductTable.js
import Category from './Category';
import Product from './Product';

export default function ProductTable({products}){
  // ...
  <Category category={products[i].category}
  // ...
  <Product product={products[i]} 
  // ...  
}

// Category.js
export default function Category({category}){}

// ProductTable.js
export default function Product({product}) {}
```

这里我定义了五个文件，每个文件中都最多有一个的组件。

-   index.js 文件：它是根文件，在该文件中```registerComponent```方法，会调用根组件 App，然后开始逐级调用，渲染应用；
-   App 组件：在 App 组件中，用于表示商品信息的数据变量 ```PRODUCTS```，在被调用时会通过 ```ProductTable```组件的 ```products``` 属性传递下去；
-   ```ProductTable``` 组件：它被 App 组件调用后，它的调用入参就是 products。products 是一个数组，数组中的每一项就是 ```Product```组件的入参```product```。每一项中的分类，就是`Category` 组件的入参 `category`。还是一样，组件首字母是大写的，属性、入参的首字母是小写的；
-   Category 组件：它会被` ProductTable `组件调用两次，第一次调用接收的入参`category`是“水果”，第二次是“蔬菜”；
-   Product 组件：它会被 `ProductTable `组件调用 6 次，生成 6 个不同的商品元素，展示在手机屏幕上。

简而言之，**组件间的数据是单向流动的，是逐层往下传递的**。调用是从根组件开始的，根组件会调用其子组件，子组件会调用子子组件，以此类推。调用过程中，数据会被当做组件的属性，层层传递下去。

### 总结

前面我们说了，React/React Native 之所以选择基于组件的方式来构建应用，原因就在于组件更能够满足现代应用重交互重展示的特点。

搭建 React Native 静态页面的核心就是搭建组件。它的整体思路是，从上往下拆出组件，从下往上把拆出来的组件进行逐一实现和拼装。

在这一讲中，我们搭建的静态页是一个无交互的、轻展示的应用，但 React/React Native 也表现得很好。只要我们遵循单一责任原则，对 UI 设计稿进行拆分，我们就能设计出一个可扩展的、可维护的应用。

即使后续这个应用有了复杂的交互、有了复杂的展示形式，它也能很好地扩展。我们只需把那些复杂的组件，那些不再符合单一责任原则的组件，进行拆分就可以了。

最后，请你牢牢记住，宿主组件是最基础的材料，所有我们自定义的复合组件都基于宿主组件搭建出来的，而复合组件又能搭建出更上层的复合组件，这样一步一步，我们才能把静态页面搭建完成。

### 补充材料

学习 React 最好的地方就是 [React 官网](https://react.dev/)。我给的官网地址是新官方地址，目前还是 beta 版本，但不妨碍它是学习 React 最好的地方。这一讲中商品列表静态页的案例，也是参考的 React 新官网改编的；

这节课里完整的商品列表静态页代码，我放在了 [GitHub](https://github.com/aiyin10001/MyReactNativeLearn1) 上；

## 03｜Style：关于样式你需要知道的三件事

上一讲我们说到，搭建页面的第一步是搭建静态页面，拿到设计稿后要从上往下拆成组件，再从下往上把组件进行实现。

但组件只是页面的架子。如果你不使用任何样式，组件只能遵循默认的布局规则、默认字号颜色，铺在屏幕上，看起来就像调试的 log 信息一样，也没有什么体验可言。

俗话说人靠衣装、佛靠金装，页面体验要好就离不开样式的帮助。大家对 App 的第一印象，就是对页面样式的第一印象。虽说样式设计上是由设计师负责，但最终落地还得靠代码。如何把设计师给的设计稿在不同大小的机型上还原实现，通过验收，是工作中实实在在要面对的考验。

还原设计稿还只是最基本的要求，作为开发者，你还得要关心开发成本、可维护性、布局性能等事情。比如，有哪些样式库可以节约开发成本？代码量大了需求有变动，样式怎么改起来更方便？React Native 的布局性能究竟怎样，多层嵌套的复杂布局会不会导致性能问题？

所以今天，围绕着上面这些话题，我和你一起聊聊，关于样式你需要知道的三件事：

-   React Native 组件样式都有哪些？
-   React Native 的 Flex 布局有哪些特点？
-   React Native 样式代码如何管理？

### 组件样式 = 通用样式 + “私有”样式

我们先来说说，React Native 组件样式都有哪些。

还原设计稿离不开样式的支持，样式决定了组件在屏幕中的样子。大部分 React Native 提供的框架组件都有样式属性，也就是 style 属性。比如，你要改变文字的颜色，就需要给 Text 组件的 style 属性传一个` {color: 'red'}` 对象。如果要设置文字一个圆角边框，那就要稍微复杂一点了，需要三个样式值：边框颜色 borderColor、边框宽度 borderWidth、边框半径 borderRadius，比如这段示例代码：

```jsx
// 文字颜色
<Text style={{color:'red'}}>
// 圆角边框 
<Text style={{borderColor:'green', borderWidth: 1, borderRadius: 5}}>  
```

不过，不同组件的支持的样式可能会有些不同。比如，上面这段代码中，文字颜色 color 只有 Text 和 TextInput 组件有，图片组件 Image 没有文字也不需要 color 样式。而边框样式 border*（比如 borderColor、borderWidth、boderRadius 等等），容器组件 View、文字组件 Text、图片组件 Image 都有。

那我们怎么知道哪个组件都有哪些样式？要死记硬背吗？当然不用。

一方面，通过 TypeScript 声明文件，编辑器会提醒你某个组件都有哪些样式。另一方面，React Native 的组件样式是有规则的，你只需要把那些高频样式用会就可以了，其他低频样式，等要用到的时候再翻文档也不迟。

组件样式是有继承关系的，可以分为三层：

-   第一层是通用样式；
-   第二层是 View 组件样式；
-   第三层是 Text、Image 等其他组件样式。

我把组件样式的三层继承规则整理成了一张图片，相信你看完之后会有更深刻的理解：

![](rn-5.png)

通用样式包括布局 Layout、变换 Transform 和阴影 Shadow。容器组件要不要展示归布局 Layout 管，位置确定后要往左边挪点还是旋转个角度归变换 Transform 管，要立体感要加个阴影归 Shadow 管。

View 组件样式继承了所有通用样式，包括布局 Layout、变换 Transform、阴影 Shadow，除此之外，还有自己的“私有”样式，比如背景颜色 backgroundColor、透明度 opacity、背面可见 backfaceVisibility。另外，Android API 28 以下用的阴影属性 elevation 也是 View 的“私有”样式，为了记忆方便，你也可以将其归类到阴影 Shadow 上。

大部分组件，比如 Text、Image 组件，都继承了 View 组件样式。因此 View 组件的背景色 backgroundColor、Android 低版本阴影 elevation 等“私有”样式，其实也可以算作通用样式。

但 Text 组件、Image 组件的“私有”样式，就不能相互通用了。文字颜色 color、字体大小 fontSize、文字行高 lineHeight，这些是文字组件独有的，图片组件就不能用。图片大小模型样式 resizeMode 是图片独有的，文字组件也不能用。

简而言之，组件样式 = 通用样式 + “私有”样式，View 组件样式可以算作通用样式，而 Text 和 Image 组件各有各的“私有”样式。

### Flex：跨平台、高性能、易上手

在所有样式中，你用的最多一定是布局样式（Layout），而布局样式中大部分都是 Flex 相关的弹性布局。

React Native 在 2015 年诞生之初，就选择使用 Flex 作为默认的布局方式，到现在为止也仅仅只支持了 Flex 弹性盒子布局和 Absolute 绝对定位这两种布局方法。而 Flex 这种布局方式，也经受住了时间的考验，得到更多开发者的认同。

Flex 布局有三个特点：**跨平台、高性能、易上手**。

首先 Flex 布局是跨平台的，这里说的跨平台有两层含义。第一层含义是 Flex 布局并不是 React Native 所独有的，在 Web、Android、iOS 平台也都在用，Flex 布局知识的可迁移性很强。无论是前端开发还是客户端开发，你在你当前领域掌握的 Flex 知识，可以直接拿到 React Native 上用，反之亦然。

跨平台的第二层含义是，React Native 的布局引擎 Yoga 是 Android、iOS 通用的。你给组件写的 Flex 布局代码，最终都会被 Yoga 引擎计算为精确的坐标系，然后按照计算后的坐标系把组件渲染到屏幕上，这个布局计算在双端是一致。

有些同学写代码的时候，可能一开始就担心，“这么写是不是会嵌套太深了，会不会引起布局性能问题？”，“设计师给的布局太复杂了，性能会不会不好啊？”。其实这些性能问题大可不必担心，正常写就行，Flex 布局用的 Yoga 引擎性能很好。

我这里放了一张布局引擎性能对比图，图片来源于 Github 开源仓库 [《Layout Framework Benchmark》](https://github.com/layoutBox/LayoutFrameworkBenchmark)。核心代码贡献者 Luc Dion 是一位 iOS 开发工程，他用 100 次 UICollectionView 布局耗时作为基准，横向对比了多款 iOS 布局引擎性能。其中就包括由苹果官方提供了 UIStackViews 和 Auto layout 布局引擎，还有使用 Yoga 实现 FlexLayout 布局引擎。

<img src="tu6.png" style="zoom:50%;" />

在图中你可以看出，虽然 iPhone 每代的性能越来越好，100 次 UICollectionView 的布局耗时越来越少。但从框架性能角度看，**使用 Yoga 实现的 FlexLayout 布局引擎比苹果官方提供了 UIStackViews 和 Auto layout 布局引擎，耗时减少了将近一个量级**。

这样看来，React Native 中的 Flex 布局确实是挺好的，那上手难不难？不难，易学易用，上手就会。

前面我们也提到过，Flex 其实是一种通用的布局方式，它引入了弹性布局的概念，这个概念在各平台都是一样的。但在具体的写法上，各个平台可能会有一些差异。

我用最常见三种布局给你举些例子，它们包括从上往下排列布局、左图右文布局、文字居中布局。你可以感受一下，React Native 的 Flex 布局，和你在其他平台使用过的 Flex 布局有什么差异。

#### 第一个例子，从上往下排列布局。

在同一个父容器中，放三个子容器 View，父容器不写任何的样式，子容器只给一个固定高度，三个子容器就是从上往下排列的。

这里强调一下，父容器 VIew 的默认样式是`{display: "flex",flexDirection:'column'}`。也就是说，父容器是弹性盒子，且主轴是纵轴，子元素会沿着纵轴（主轴）方向排列，因此在父元素不写任何样式时，子元素是从上往下排列的。示例代码如下：

```jsx
<View>
  <View style={{height: 50, backgroundColor: 'powderblue'}} />
  <View style={{height: 50, backgroundColor: 'skyblue'}} />
  <View style={{height: 50, backgroundColor: 'steelblue'}} />
</View>
```

#### 第二个例子，左图右文布局。

在同一个父容器中，放一个 Image 和一个 Text。为了让图片文字左右排列，我们需要给父容器设置布局样式`{flexDirection: 'row'}`。为了让图片不拉伸变形，我们需要给图片 Image 设置一个固定宽高。为了让文字将剩余宽度铺满，我们需要给文字 Text 设置 `{flex: 1}`。这时，父容器的主轴是横轴，子元素会沿着横轴（主轴）方向排列，整体布局是左图右文。具体的代码如下：

```jsx
<View style={{flexDirection: 'row'}}>
  <Image
    style={{width: 100, height: 100}}
    source={{
    uri: 'https://placeimg.com/640/480/cats',
  }}
  />
  <Text style={{flex: 1,fontSize: 18}}>我是文字</Text>
</View>
```

#### 第三个例子，文字居中布局。

曾经有一道经典的面试题，“父容器高度确定，使其子元素 Text 水平垂直方向居中”，不过自从有了 flex 后，这道题的难度降低了很多，问的频率也变低了。

我们通过 alignItems 和 justifyContent 的配合，很容易实现水平垂直方向的居中布局，示例代码如下：

```jsx
<View
    style={{
      alignItems: 'center',
      justifyContent: 'center',
      // 高度确定
      height: 60,
      borderWidth: 1,
    }}>
    <Text
      style={{
        fontSize: 18,
        // 文字默认内边距，会导致垂直居中偏下
        includeFontPadding: false,
        // 文字默认基于基线对齐，会导致垂直居中偏下
        textAlignVertical: 'center',
      }}>
    我是文字1
    </Text>
</View>
```

在这段代码中，你只需要给父容器设置`{justifyContent: 'center',alignItems: 'center'}`，使子元素分别在主轴（纵轴）和副轴（横轴）方向居中就可以了。这里有个小细节，Android 文字默认会有内边距且基于基线对齐，这会导致文字垂直居中时偏下。**因此垂直居中时，最好把内边距关掉，并把文字放在中线而不是基线上**。

当然，文字水平垂直方向居中，除了 Flex 方案，还有行高方案，感兴趣的同学也可以自己研究一下，这里就不再介绍了。

讲完这三个例子后，你是否发现 React Native 与你所熟悉的其他平台，在 Flex 布局上的不同点了呢？你可以在心里对照一下，这样做能帮你学得更快。

### StyleSheet：分离、复用、性能好

在前面的几个例子中，我们写样式用的都是内联的方式。内联样式就是直接在 JSX 的元素属性中写样式，这样写起来是很方便，但是却把 JSX 的元素结构和样式混在一起了。

既然样式属性可以内联，那事件属性也可以内联，甚至所有的属性都可以内联。而且现在 JSX 模板既要声明元素结构，又要写样式、事件、属性逻辑，整一个大杂烩。写起来是很爽，但维护起来就很“酸爽”了。

此外，内联样式还存在不能复用，性能损耗的问题。首先，即便两个文字组件的样式是一样的，内联样式也不能重复使用，必须在两个组件中各写一套。其次，每次执行自定义组件函数生成元素时，或实例化元素时，样式对象都要重复创建，这导致了性能损耗。你可以看看这段示例代码感受一下：

```jsx
// 各种内联，导致 JSX 结构不清楚。
<View
      // 普通属性
      hitSlop={
      top: 10,
      bottom: 10,
      left: 0,
      right: 0
    }
      // 事件属性
      onLayout={() => {
      // 事件逻辑
      }}
      // 样式属性
    style={{
      alignItems: 'center',
      justifyContent: 'center',
      height: 60,
      borderWidth: 1,
    }}>
    <Text
      style={{
        fontSize: 18,
        includeFontPadding: false,
        textAlignVertical: 'center',
      }}>
    我是文字1
    </Text>
    <Text
      style={{
        fontSize: 18,
        includeFontPadding: false,
        textAlignVertical: 'center',
      }}>
    我是文字2
    </Text>
</View>
```

所以，我推荐你使用样式表 StyleSheet 来写样式，而不是内联的方式。使用样式表 StyleSheet 有三个好处：

-   元素结构和样式分离，可维护性更好；
-   样式对象可以复用，能减少重复代码；
-   样式对象只创建一次，也减少性能的损耗。

比如，面对上面这种大杂烩的代码，你可以试着把内联样式等属性抽离出来，没有了冗余的样式和属性，我们一眼就能看出原本的 JSX 结构：

```jsx
// JSX 结构
<View
      hitSlop={hitSlop}
      onLayout={handleLayout}
    style={styles.container}>
    <Text style={styles.texts}>我是文字1</Text>
    <Text style={styles.texts}>我是文字2</Text>
</View>

// 样式表
const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
    height: 60,
    borderWidth: 1,
  },
  texts: {
    fontSize: 18,
    includeFontPadding: false,
    textAlignVertical: 'center',
  }
});
```

你看，这是一个容器组件 View 嵌套了两个文字组件 Text。样式结构分离后，逻辑也更加清晰，维护起来也会容易很多。

而且，在这段代码中，两个 Text 组件使用了同一个样式对象 styles.texts，也实现了复用。样式对象在代码初始化时就创建好了，每次执行就不用再创建了，这样减少了性能损耗。

### 课程小结

我们前面说了，样式决定了页面的“颜值”，关于样式你需要知道这三件事：

1.   大部分框架提供的组件都有自己的样式属性 style，包括通用样式和“私有”样式。其中 View 组件样式可以看做通用样式，而 Text 组件、Image 组件各有各的“私有”样式；
2.   在所有样式中，最常用的是 Flex 布局，也是你的学习重点。React Native 的 Flex 布局和其他平台的 Flex 布局模型基本相同，如果你有过 Flex 的使用经验，只需结合示例掌握 React Native 中的那些不同点就能快学会；
3.   内联样式写 Demo 是没有问题的，但在实际的生产中我更加推荐你使用样式表 StyleSheet 来进行样式管理。

React Native 的样式大都是从 Web 中借鉴过来的，并且还进行了“CSS in JS”的改良，相信你学起来会非常快。

如果你问我学习样式还有什么技巧，那我会告诉你，无他，唯手熟尔。只要多多练习就能学好。学习样式不需要严格的推理逻辑，需要的只有勤加实践，当初我入门的时候，就是通过模仿国内电商的官网，把样式给打通关的，你也赶紧试试吧。

### 补充材料

**样式学习材料**：React Native 的样式其实很简单，所有的核心样式在的源码中只有 1 份声明文件StyleSheetTypes。这一份声明文件对应的是官网的 6 篇文档：View Style Props、Text Style Props、Image Style Props、Layout Props、Shadow Props、Transforms。

**Flex 学习材料**：Yoga 官网提供了 Flex 弹性盒子布局的在线试用应用 Playground，你可以动手把玩一下。React Native 官网也为你提供了沙盒环境的相关。

**样式管理资料**：今天只介绍了样式表 StyleSheet这种最基础的样式管理方案。业内主流的方案还有带样式的组件 styledComponent 和样式简写方案 tailwind，它们虽然是源自浏览器的 CSS 管理方案，但也可以在 React Native 中使用。在推特上也有关于样式管理方案的讨论，你可以看看大家的看法是什么。业务代码的样式管理没有银弹，选择适合你的就好了。

## 04｜State：如何让页面“动”起来？

怎么让页面“动”起来呢？这就要用到状态 State 了。

一个页面也好，一个应用也好，只有把状态设计清楚了，程序才能写得好。讲到状态，有些人可能会说，状态不就是页面中那些会“动”的数据吗？这很简单，还有什么好讲的。

这没错，状态确实是页面中会“动”的数据，但是要把状态用好不容易，有时候容易把状态设计复杂了，不仅代码要写得更多，还容易导致程序维护起来更麻烦。

这次，我会以搭建一个会“动”的简易购物车页面为例，和你分享下我在这方面的经验。简易购物车页面是这样的：

<img src="tu7.png" style="zoom:50%;" />

它比上一讲的商品表单页多了一些交互，它的所有数据都是从网络请求过来的，这些数据包括商品名称、商品价格、商品数量，数据从网络请求回来后会展示在页面上。你可以点击页面中的加号或减号，来添加数量或减少商品数量，底部的结算总价会随着商品数量的变化而变化。

要实现这个简易购物车的静态很简单，它只包括两个组件，商品表单组件 ProductTable 和商品组件 ProductRow。完成静态页面的搭建后，接下来就要让**页面“动”起来了**，我把这个过程分成了 4 步来实现，状态初选、状态确定、状态声明、状态更新。

### 第一步：状态初选

状态初选说的是，先看看页面那些数据是会变化的，这些会变化的数据都可能是状态，我们先把它们找出来。

程序本身的事件和用户操作都有可能导致页面发生变化，因此我们从这两个方向来进行初选。

程序本身的事件，比如网络请求、 setTimeout，都可能导致页面发生变化。在购物车页面中，商品列表的数据是从服务端请求过来，在列表数据从服务端回来之前，页面是空白的，在请求过程中会有加载提示，请求成功后购物车页面就会展示出来，当然还要把请求失败的情况考虑进去。

所以，我圈选出来的第一条动态数据是请求过程，第二条是可能的请求失败情况；第三条是商品表单本身，第四条是所有商品的结算总价。

用户操作，比如点击、滑动、缩放，也可能导致页面发生变化。在购物车页面中，用户点击加号购物车中的商品数量会增加，点击减号数量会减少。反映商品数量的数据，就是第五条的动态数据。

现在，我已经把这 5 个初选的状态给你在图中标出来了：

<img src="tu8.png" style="zoom:50%;" />

### 第二步：状态确定

有些人完成状态初选这一步后，就直接写起代码来了，一口气声明了 5 个状态，然后想办法去操作这 5 个状态如何变化。

但我的经验是，状态初选完成后，不能急着写代码，要先确定一下这些初选状态中那些是真正的状态，把其中无用的状态剔除掉，然后再去写代码。这样代码写得少、写得快，代码逻辑也会更简单一些，也更难出 BUG 一些。

这些都是我们要在状态确定这一步要做的，我总结了三条经验：

1.   **首先，一件事情一个状态**。我发现有些同学写代码的时候，在定义请求状态时，喜欢用布尔值 isLoading 来表示空闲状态或请求中的状态，用 isError 来表示成功状态或失败状态，明明就是网络请求这一件事，却用了两个状态来表示，这就有点多余了，甚至在一些不好测试的边界条件下可能还会留坑。

     这时其实只需要定义一个状态 ，代码示例如下：

     ```jsx
     const requestStatus = {
       IDLE : 'IDLE',
       PENDING : 'PENDING',
       SUCCESS : 'SUCCESS',
       ERROR : 'ERROR',
     }
     ```

     这里，我定义的是一个枚举对象 requestStatus，用它来表示请求状态。这个对象有 4 个值，包括请求空闲 IDLE、请求中 PENDING、请求成功 SUCCESS、请求失败 ERROR。你看，用一个状态是不是比用两个状态更加贴合请求的实际情况呢？

2.   **第二，重复状态不是状态**。商品组件 ProductRow 中的这个商品数量确实是一个状态，但它却和从网络请求中回来的商品表单状态重复了。从代码层面上，我们确实有办法同时保留两个状态，但这样做就绕弯子了。

     更好的做法是，把这两个在不同组件之间的重复状态进行合并，去掉底层组件的重复状态，只保留顶层组件中的商品数量作为唯一的状态。

3.   **最后，可计算出来的状态不是状态**。一个状态必须不能通过其他状态、属性或变量直接计算出来，能通过其他值计算出来的状态，都不是状态。比如，在购物车页面中，结算总价这个动态数据，是可以通过对所有商品的单价和数量的积进行求和得出来的，所以它不是状态。

     ```
     结算总价 = ∑(商品的单价 * 数量)
     ```

     初选的状态经过以上三步筛选之后，合并了①请求中和②请求失败，避免了重复数据③商品列表和⑤商品数量，根据已有状态推导出了④结算总价。初选状态一共 5 个，最终确定下来就只剩下网络请求状态和商品列表这两个状态了。

     只有确定状态这一步做好了，你声明状态和改变状态，才会变得容易。

### 第三步：状态声明

React 提供了 useState 状态声明函数，你可以用它来管理函数组件的状态。

使用 useState 声明状态时，状态和组件是绑定的关系，useState 在哪个组件中使用，它生成的状态就属于那个组件。由于单向数据流的原因，React 把父组件的状态传给子组件只需要传一次，传给子子组件需要传递两次。

因此，你在定义状态的时候，一定要先考虑好把状态绑定到哪个组件上。我建议你用就近原则来绑定状态，就近原则的意思是哪个组件用上了状态，就优先考虑将状态绑定到该组件上，如果有多个组件使用了同一个状态，则将其绑定到最近的父组件上。这样做能让使用 props 传递状态的次数最少。

在我们的购物车案例里，你使用就近原则判断一下，你就可以确定购物车页面的两个状态，其实放在 ProductTable 组件中比较合适。

那接下来的问题是，状态声明代码应该如何写？

首先，我需要和你强调的是，在 React/React Native 中，所有使用 use 开头的函数，比如接下来要用到 useState 函数，它们都叫**钩子函数（hook function）**。和普通函数不同，你不能把钩子函数写在 if 条件判断中、事件循环中、嵌套的函数中，这些都会导致报错。

钩子函数类似于 JavaScript 的 `import` ，你最好在函数组件的顶部使用它们。

具体声明商品表单状态 products 和请求状态 requestStatus 代码是这样的：

```tsx
import React, {useState} from 'react';

export default function ProductTable() {
  const [products, setProducts] = useState([]);
  const [requestStatus, setRequestStatus] = useState('IDLE');
  // ...
}
```

在文件的第一行代码中，我们从 React 中引入 useState 函数，然后在函数组件 ProductTable 的顶部使用了 useState 声明了两个状态。

useState 函数的入参是状态的默认值，函数的返回值是状态和更新该状态的函数。第一次调用 useState 函数后，就生成了默认值是空数组`[] `的商品表单状态 `products `，以及设置该状态的函数`setProducts`。第二次调用 useState 函数后生成了默认值是字符串'IDLE' 的请求状态 `requestStatus` ，以及设置该状态的函数叫做`setRequestStatus`。

如果在 if 中使用了任何的钩子函数，就会报错：

```tsx
import React, {useState, useEffect} from 'react';

// 错误
export default function ProductTable() {
  const [requestStatus, setRequestStatus] = useState('IDLE');
  // ...
  if(requestStatus === 'ERROR') return <Text>网络出错了</Text>

  // 在 else 分支中，使用任何 use 开头的钩子函数，都会报错
  const [products, setProducts] = useState([]);
  useEffect(() => {})
  
  return <Text>购物车页面</Text>
}
```

在这个错误示例中，我们先使用了` if(requestStatus === 'ERROR') `判断了网络请求状态。如果请求失败，则提示用户“网络出错了”，否则就返回真正的购物车页面。但` if return `后面的代码，就相当于else`分支`，在分支中使用了钩子函数，比如 `useState`、`useEffect`，代码就会报错。

出现这种报错，是因为 if 破坏了 React 的 [Hook 规则](https://zh-hans.legacy.reactjs.org/docs/hooks-rules.html)。在 React 的 Hook 机制中，是把 Hook 的调用顺序作为索引，用它把 React 框架内部 state 和其函数组件的 useState 返回值中的 state 给关联起来了。当你使用了 if 的时候，就容易破坏 Hook 的调用顺序，导致 React 不能正确地将框架内部 state 与函数组件 useState 的返回值关联起来，因此 React 在执行的时候就会报错。

有时候一个函数组件很长，写到后面了，前面的一些逻辑就记不那么清楚了，如果代码写到哪就在哪儿声明一个新状态，一不小心就可能会踩坑。因此，你应该把 use 开头的钩子函数都写在组件的顶部，把 JSX 都写在函数组件的最后面，并使用 [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks)插件来保障 Hook 规则的会被正确执行。

### 第四步：状态更新

现在，到了最后一步了。不过，这一步中涉及购物车页面业务实现逻辑的部分，我就不一一介绍了，具体实现代码我放到了附加材料中，这里我想重点和你强调的是如何更新对象类型的状态。

在 JavaScript 中的数据类型可以分为两类，对象数据类型（Objects）和原始数据类型（Primitive values），对象数据类型包括对象（Object）、数组（Array），原始数据类型有 7 种，比如数字（number）、字符串（string）等等。

在 React/React Native 中，使用这两类数据类型作为状态都是可以的，但是更新这两类状态的方法不一样，如果你没有理解清楚二者的区别，就容易出现一些低级的 BUG。

我们先来看原始数据类型的状态如何更新。

在购物车页面中，商品数量可以通过点击加号进行加一，通过点击减号减一。我们用原始数据类型数字来表示商品数量状态，其代码实现如下：

```jsx
export default function Count() {
  const [count, setCount] = useState(0);

  return (
    <View>
      <Text>{count}</Text>
      <Button title="+" onPress={() => setCount(count + 1)} />
      <Button title="-" onPress={() => setCount(count - 1 >=0? count - 1: 0)} />
    </View>
)};
```

你可以看到，我们使用 useState 声明了商品数量状态 count 和更新状态的函数 setCount。

组件初始化时，也就是组件函数第一次调用时，商品数量状态 count 的默认值是 0，页面展示的数字就是 0。

当你点击页面中的加号（“+”）时，就会触发加号（“+”）点按组件（Button）的点击事件（onPress），此时会调用 setCount 函数更新状态。

setCount 函数的入参是 count + 1，其中 count 取的是组件第一次调用的默认值 0，0 + 1 = 1，因此新状态就是 1，之后 React/ React Native 会再调用一次组件函数，这一次调用时 useState 声明的状态 count 的值就是新状态的值 1，此时 Text 组件收到的值也是 1，最后页面刷新展示新状态 1。

第二次点击加号时，也是先更新 React/ React Native 内部的新状态，将它更新到 2，然后再执行一次组件函数，将内部的新状态同步给 count，最后刷新页面展示新状态 2。

以此类推，**对于原始数据类型而言，调用 setCount 更新原始数据类型状态的值，页面就会发生更新**。

那对象和数组类型的状态如何更新呢？

我们先声明一个对象状态和一个数组状态，代码如下：

```jsx
const [countObject, setCountObject] = useState({num: 0});
const [countArray, setCountArray] = useState([0]);
```

这段代码中，调用了两次 useState，声明一个对象状态 countObject 和一个数组状态 countArray，以及对应的状态更新函数。

理论上，你可以直接改变对象状态或数组状态的值，再调用状态更新函数，代码如下：

```tsx
countObject.num++;
setCountObject(countObject)

countArray[0]++;
setCountArray(countArray)
```

但是你试过后会发现，调用状态更新函数后，页面什么变化都没有，这是为什么呢？

弄清楚了对象数据类型（Objects）和原始数据类型的区别后，你就明白了。我给你举个例子：

```jsx
const countObject = {num: 0}
countObject.num++;

countObject.num === countObject.num // false
countObject === countObject // true
setCountObject(countObject) // 不更新
```

你看，当你更新 countObject.num 时，countObject.num 确实更新了，但是 countObject 的引用并没有更新，所以调用 setCountObject 更新状态时，页面没有任何变化。

这是因为，对象它是一种复合数据类型，它内部的值是可变的（mutable），但它的引用是不可变了（immutable），你更新了对象的内部值后，它的引用并没有发生变化。

那状态是对象或数组时，应该怎么更新呢？

业内也有形似 mutable 的更新方案 useImmer，可以通过直接修改变量的值来更新状态。但其底层原理也是，新建一个对象或数组传给状态更新函数，让状态更新函数知道对象或数组确实发生了变化，这时 React/React Native 框架才会帮你更新页面。

这里，我用的也是直接新建对象、新建数组的方式，代码如下：

```jsx
setCountObject({...countObject, num: countObject.num+1});

const newCountArray = [...newCountArray]
newCountArray[0]++;
setCountArray(newCountArray)
```

你可以看到，对于对象状态的更新我是这么处理的，我先创建了一个新对象{}，然后用...的解构的方式将老对象 countObject 的内部值重新赋值给了新对象{}，再指定num属性进行了复写。对于数组状态的更新也是类似的，你可以自己试试。

### 总结

这一讲，我们完成搭建页面的第二步：让页面“动”起来。让页面“动”起来，就要用到状态，我们这一讲的具体实现分为 4 个步骤，状态初选、状态确定、状态声明、状态更新。

-   状态初选，就是把设计稿中的那些会“动”的数据先选出来；
-   状态确定，就是合并同类状态、删除无用状态和衍生状态；
-   状态声明，在当前的初学阶段，只需要学会使用 useState 来声明组件状态即可；
-   状态更新是最后一步。交互事件和程序事件会触发状态的更新，但状态更新函数并不会帮我们自动合并上一个状态，因此在处理对象状态和数组状态时，每次更新时必须新建一个完整的对象或数组。

行军作战是兵马未动粮草先行，讲究的是谋而后动。搭建页面、开发组件也是如此，我们也要**代码未动构思先行**，先把组件状态设计好了，简单即美，要是没想清楚弄复杂了，后面填坑成本会很高。

## 05｜Image：选择适合你的图片加载方式

今天我们来讲解 React Native 框架中的 Image 组件。顾名思义，图片组件 Image 就是用来加载和展示图片的。

你可能会觉得，图片组件的基础用法非常简单呀，学起来也很容易上手，这有什么好讲的呢？没错，正因为它很简单，有时候，我们可能会忽视对这些基础知识的琢磨。在日常开发中，图片是影响用户体验的关键因素之一，它很常见，基本上哪里都有它。而且相对于文字，图片也更容易抓住用户的眼球。图片组件很重要，但要用好却不那么容易。

React Native 的 Image 组件一共支持 4 种加载图片的方法：

-   静态图片资源；
-   网络图片；
-   宿主应用图片；
-   Base64 图片。

这 4 种方案给我们业务提供了更灵活的选择空间，但同时也让不少同学犯了选择困难症，不同情况下我该怎么选呢？今天，我们就来深度剖析这 4 种方案分别的适用场景是什么，并给你介绍一下我推荐的最佳实践。

### 静态图片资源

静态图片资源（Static Image Resources）是一种使用**内置图片**的方法。静态图片资源中的“静态”指的是每次访问时都不会变化的图片资源。站在用户的视角看，App 的 logo 图片就是不会变化的静态图片资源，而每次访问新闻网站的新闻配图就是动态变化的图片。

如果图片每次都不会变化，那么你就可以把这张图片作为静态图片资源，内置在 App 中。这样，用户在打开你的 App 时，图片是从本地直接读取的，直接读取图片的速度比走网络请求先下载再加载的速度要快上很多。一张网络图片从下载到展示的耗时通常需要 100ms 以上，而一张内置图片从读取到展示的耗时通常只有几 ms，甚至更低，二者耗时相差了两个数量级。

因此，在一些高性能场景下，你应该选择把这些不经常变动的静态图片资源内置到 App 中。当用户打开 App 时，这些图片就能够立刻展示出来了。

那我们具体是怎么使用静态图片资源的呢？这里我们可以分为 3 步。首先，把图片放到 React Native 的代码仓库中，然后通过 require 的方式引入图片，最后把图片的引用值传给 source 属性。Image.source 属性是用来设置图片加载来源的。

这里我们需要注意的是，require 函数的入参必须是字面常量，而不能是变量。你可以看下这段代码：

```tsx
// 方案一：正确
const dianxinIcon = require('./dianxin.jpg')
<Image source={dianxinIcon}/>

// 方案二：错误
const path = './dianxin.jpg'
const dianxinIcon = require(path)
<Image source={dianxinIcon}/>
```

在这段代码中，方案一是静态图片资源正确的使用方式，方案二是错误的。方案一用的是图片相对路径的字面常量，也就是`'./dianxin.jpg'`。而方案二，用的是图片相对路径的变量，也就是 path 。

你是不是很好奇，为什么使用 require 函数引入静态图片资源时，require 入参，也就是图片的相对路径，必须用字面常量表示，而不能用变量表示？静态图片资源的加载原理又是什么呢？我们接下来继续分析。

#### 静态图片资源的加载原理

我们还是用加载点心图片（dianxin.jpg）为例，从编译时到运行时，剖析加载静态资源图片的全过程，一共分为三步。

**第一步编译**：在编译过程中，图片资源本身是独立于代码文件之外的文件，图片资源本身是不能编译到代码中的，所以，我们需要把图片资源的路径、宽高、格式等信息记录到代码中，方便后面能从代码中读取到图片。

你可以选一张你喜欢吃的点心的图片，命名为 dianxin.jpg，并把点心图片和 index.js 文件放在同一层级目录下。然后在 index.js 中通过 require 方法把点心图片引入进来，交由 Image 组件使用。

在你引入静态图片资源完成后，可以先本地试试图片是否能正常展示。如果展示没有问题，直接运行`react-native bundle`的打包命令，开始打包编译：

```cmd
npx react-native bundle --entry-file index.tsx --dev false --minify false --bundle-output ./build/index.bundle --assets-dest ./build
```

这段打包（bundle）命令的意思是，以根目录的 index.tsx 文件为入口（entry file），产出 release（dev=false）环境的包，这个包不用压缩（minify=false），并将这个包命名为 ./build/index.bundle，同时将静态资源编译产物放到 ./build 目录。这个 build 目录结构如下：

```
./build
├── assets
│   └── src
│       └── Lesson3Image
│           └── dianxin.jpg
└── index.bundle
```

编译后的产物会都存在 build 目录中，这个目录需要你提前创建好，否则会有报错提示。编译完成后，你可以在 build 目录中找到 index.bundle 文件，它是编译后的 JavaScript 代码。另外， build 目录中还有一个 assets 目录，assets 目录放的是编译后的图片 dianxin.jpg。

然后我们再打开 index.bundle 文件，搜索 dianxin 关键字。我们可以找到一个和 dianxin 关键字相关的独立模块，这个模块的作用就是将静态图片资源的路径、宽高、格式等信息，注册到一个全局管理静态图片资源中心。这个独立模块的代码如下：

```tsx
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/src/Lesson3Image",
    "width": 190,
    "height": 190,
    "scales": [1],
    "hash": "0d4ac32eb69529cf90a7b248fee00592",
    "name": "dianxin",
    "type": "jpg"
  });
```

它主要包括该图片的注册函数 registerAsset 和其注册信息。其中图片的注册信息包括，目录信息（/assets/src/Lesson3Image）、宽高信息 （width 和 height）、图片哈希值（hash）、图片名字（dianxin）、图片格式（jpg）等等。

很明显，这个静态图片资源的注册函数和相关的图片信息代码，并不是你写的。那这段代码是怎么来的呢？它是由打包工具根据字面常量`'./dianxin.jpg'`，找到真正的点心静态图片资源后，读取图片信息自动生成的。

这里敲一下黑板，在使用 `require` 函数引入静态图片资源时，图片的相对路径必须用字面常量表示的原因是，**字面常量`'./dianxin.jpg'`提供的是一个直接的明确的图片相对路径**，打包工具很容易根据字面常量`'./dianxin.jpg'` 找到真正的图片，提取图片信息。而变量path 提供的是一个间接的可变化的图片路径，你光看`require(path)` 这段代码是不知道真正的图片放在哪的，打包工具也一样，更别提自动提取图片信息了。

这里还需要注意一下，我们第一步“编译时”生成的图片注册函数和其注册的信息，我们在后面的第三步“运行时”还会用到。

**第二步构建**：编译后的 Bundle 和静态图片资源，会在构建时内置到 App 中。

如果你搭建的是 iOS 原生环境，那么你应该运行` react-native run-ios` 构建 iOS 应用。如果你搭建的是 Android 原生环境，那么你应该运行` react-native run-android `构建 Android 应用。

不过，默认构建的是调试包，而我们想要的是正式包，因此我们还需要在命令后面加一行配置`--configuration Release`。这样就能在你的真机或者模拟器上，构建出一个 React Native 应用了，具体命令如下：

```
$ npx react-native run-ios --configuration Release
```

在这一步，编译后的 Bundle，包括 Bundle 中的静态图片资源信息，和真正的静态图片资源都已经内置到 App 中了。现在你可以关闭网络，然后打开 App 试试，如果这时页面和图片依旧能正常展示，那就证明图片确实内置成功了。

实际上，上面的命令` react-native run-ios` 既包括第一步的编译 `react-native bundle`又包括第二步的构建。在真正编译和构建内置时候，你只需要运行` react-native run-ios` 即可。

**第三步运行**：在运行时，require 引入的并不是静态图片资源本身，而是静态图片资源的信息。Image 元素要在获取到图片路径等信息后，才会按配置的规则加载和展示图片。

还记得吗？我们第一步“编译时”，生成了图片注册函数和其注册的信息，在第二步“构建时”，我们将真正图片内到了 App 中。那在第三步“运行时”，我们怎么拿到这些图片信息，并加载和展示真正的内置图片呢？

首先，你可以通过 Image.resolveAssetSource 方法来获取图片信息。具体的示例代码如下：

```jsx
const dianxinIcon = require('./dianxin.jpg')

alert(JSON.stringify(Image.resolveAssetSource(dianxinIcon)))

// 弹出的信息如下：
{
    "__packager_asset": true,
    "httpServerLocation": "/assets/src/Lesson3Image",
    "width": 190,
    "height": 190,
    "scales": [1],
    "hash": "0d4ac32eb69529cf90a7b248fee00592",
    "name": "dianxin",
    "type": "jpg"
}
```

这段代码很简单，关键代码只有两行，第一行是通过 require 引入点心图片，并将其赋值给变量 dianxinIcon。第二行是通过调用 Image.resolveAssetSource 方法，并传入点心图片变量 dianxinIcon，获取我们在编译时生成的图片信息。你可以通过 alert 字符串的方式，将它打印在屏幕上，现在你就可以在运行时，看到编译时自动生成的静态图片资源的信息了。

在 Image 组件底层，使用的就是 Image.resolveAssetSource 来获取图片信息的，包括图片目录（httpServerLocation）、宽高信息 （width 和 height）、图片哈希值（hash）、图片名字（dianxin）、图片格式（jpg），等等。然后，再根据这些图片信息，找到“构建时”内置在 App 中的静态图片资源，并将图片加载和显示的。这就是静态图片资源的加载原理。

正是因为静态图片资源加载方式，它在“编译时”提前获取了图片宽高等信息，在“构建时”内置了静态图片资源，因此在“运行时”，程序可以提前获取图片宽高和真正的图片资源。相对于我们后面要介绍的网络图片等加载方式，使用静态图片资源加载，即使不设置图片宽高，也有一个默认宽高来进行展示，而且加载速度更快。

### 网络图片

静态图片资源虽好，但它只适用于“静态不变的”图片资源，对于那些“动态变化的”和不方便内置的业务场景，那就要用到网络图片了。

网络图片（Network Images）指的是使用 **http/https 网络请求**加载远程图片的方式。

在使用网络图片时，我建议你**将宽高属性作为一个必填项**来处理。为什么呢？和前面介绍的静态图片资源不同的是，网络图片下载下来之前，React Native 是没法知道图片的宽高的，所以它只能用默认的 0 作为宽高。这个时候，如果你没有填写宽高属性，初始化默认宽高是 0，网络图片就展示不了。

具体的代码是这样：

```jsx
// 建议
<Image source={{uri: 'https://reactjs.org/logo-og.png'}}
       style={{width: 400, height: 400}} />

// 不建议
<Image source={{uri: 'https://reactjs.org/logo-og.png'}} />
```

#### 缓存与预加载

不过，网络图片虽然指的是走网络请求下载的图片，但也并不用每次都走网络下载，只要有缓存就能直接从本地加载。所以这里我们也简单介绍一下 React Native 的缓存和预加载机制。

React Native Android 用的是 Fresco 第三方图片加载组件的缓存机制，iOS 用的是 NSURLCache 系统提供的缓存机制。

Android 和 iOS 的缓存设置方式和实现原理虽然有所不同，但整体上采用了内存和磁盘的综合缓存机制。第一次访问时，网络图片是先加载到内存中，然后再落盘存在磁盘中的。后续如果我们需要再次访问，图片就会从缓存中直接加载，除非超出了最大缓存的大小限制。

例如，iOS 的 NSURLCache 遵循的是 HTTP 的 Cache-Control 缓存策略，同时当 CDN 图片默认都已经设置了 Cache-Control 时，iOS 图片就是有缓存的。

而 NSURLCache 的默认最大内存缓存为 512kb，最大磁盘缓存为 10MB，如果缓存图片的体积超出了最大缓存的大小限制，那么一些老的缓存图片就会被删除。

图片缓存机制有什么用呢？

**通过图片缓存机制和预加载机制的配合，我们可以合理地利用缓存来提高图片加载速度，这能进一步地提升用户体验。**

使用图片预加载机制，可以提前把网络图片缓存到本地。对于用户来说，提前缓存的图片是第一次看到的，但对于系统缓存来说图片是第二次加载，它的加载速度是毫秒级的甚至亚秒级的。这就是预加载机制，提升图片加载性能的原理。

举个例子，你打算买个机械键盘，打开了个购物 App，滑动手机翻页选购，键盘图片和介绍都能马上地呈现出来。你没有感受丝毫的等待和卡顿，你可能就会直接下单买了。相反，如果你选购的过程中图片加载很慢，翻页还要等待很久，你就可能会考虑换个购物 App。

在这种无限滚动的长列表场景中，图片预加载就非常适合了。React Native 也提供了非常方便的图片预加载接口 Image.prefetch：

```jsx
Image.prefetch(url);
```

也就是说，函数 Image.prefetch 接收一个参数 url，也就是图片的远程地址，函数调用后，React Native 会帮你在后台进行下载和缓存图片。这样，你下拉加载的图片时，网络图片是从本地缓存中加载的，就感受不到网络加载的耗时过程了。

### 宿主应用图片

宿主应用图片（Images From Hybrid App’s Resources）指的是 React Native 使用 **Android/iOS 宿主应用的图片**进行加载的方式。在 React Native 和 Android/iOS 混合应用中，也就是一部分是原生代码开发，一部分是 React Native 代码开发的情况下，你可能会用到这种加载方式。

使用 Android drawable 或 iOS asset 文件目录中的图片资源时，我们可以直接通过统一资源名称 URN（Uniform Resource Name）进行加载。不过，使用 Android asset 文件目录中图片资源时，我们需要在指定它的统一资源定位符 URL（Uniform Resource Locator）。

这里插个小知识，在 React Native 中，我们为什么要用 URI ，比如` { uri: 'app_icon' } `，来代表图片，而不是用更常用的 URL，比如` { url: 'app_icon' } `， 代表图片呢？

这是因为，URI 代表的含义更广泛，它既包括 URN 这种用名称代表图片的方式，也包括用 URL 这种地址代表图片的方式。以 iOS 和 Android 宿主图片为例，代码如下：

```jsx
// Android drawable 文件目录
// iOS asset 文件目录
<Image source={{ uri: 'app_icon' }} />

// Android asset 文件目录
<Image source={{ uri: 'asset:/app_icon.png' }} />
```

你可以看到，iOS 宿主图片用的是图片名称 app_icon，是 URN。而 Android 宿主图片用的是图片位置 asset:/app_icon.png，是 URL。而 URI 的所代表的含义更广，既包括图片名称 URN，又包括图片位置 URL ，所以 Image 组件的 source 属性中，代表图片名称或地址的键名是 URI。

在我们国内，绝大多数的 React Native 应用都是混合应用，都是把 React Native 当做一个支持动态更新的跨端框架来使用的。那这种情况下，我们在 React Native 中直接用宿主应用图片资源不是更好吗？

你看，React Native 静态图片资源也是内置，Android/iOS 自身图片也要内置，搞一套图片管理机制不更简单一些嘛？而且部分图片还可以跨 React Native 和 Android/iOS 两个技术栈复用，减少一些 App 体积，这听起来很不错啊。

**但在实际工作中，我不推荐你在 React Native 中使用宿主应用图片资源**。首先，这种加载图片的方法没有任何的安全检查，一不小心就容易引起线上报错。第二，大多数 React Native 是动态更新的，最新代码是跨多个版本运行的，而 Native 应用是发版更新的，应用的最新代码只在最新版本运行，这就导致 React Native 需要确切知道 Native 图片到底内置在哪些版本中，才能安全地使用，这对图片管理要求太高了，实现起来太麻烦了。

最后，开发 React Native 的团队，和开发 Android/iOS 的团队很可能不是一个团队，甚至可能跨部门。复用的收益抵不上复用带来的安全风险、维护成本和沟通成本，因此我并不推荐你使用。

### Base64 图片
最后一类常见的 React Native 图片加载方式是 Base64 图片。

Base64 指的是一种基于 64 个可见字符表示二进制数据的方式，Base64 图片指的是**使用 Base64 编码**加载图片的方法，它适用于那些图片体积小的场景。

Base64 图片的示例代码，如下：

```jsx
<Image
  source={{
    uri: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg=='
  }}
/>
```

你可以看到 Base64 图片并不是图片地址，而是以一大长串的以 data:image/png; base64 开头的文本。

通常我们看的图片资源 .jpg、.png 都是二进制格式的，二进制格式的图片是以独立文件存在的。而当二进制图片 Base64 化后，就变成了一段由字母、数字和符号组成的字符串。

通常我们看的图片资源 .jpg、.png 都是二进制格式的，二进制格式的图片是以独立文件存在的。而 Base64 图片并不是单独图片文件，而是以文本形式存在 .js 文件中的。

字符串是可以嵌套到 .js 文件中的，因此 Base64 图片也可以嵌入到 .js 文件中。在线上，Base64 图片是嵌套在 Bundle 文件中的，在加载 React Native 页面的同时，Base64 字符串也能很快地解析成真正的图片，并展示出来。

**由于 Base64 图片是嵌套在 Bundle 文件中的，所以 Base64 图片的优点是无需额外的网络请求展示快，缺点是它会增大 Bundle 的体积**。 在动态更新的 React Native 应用中，Base64 图片展示快是以 React Native 页面整体加载慢为代价的。原因就是它会增加 Bundle 的体积，增加 Bundle 的下载耗时，从而导致 React Native 页面展示变慢。

即便是相同的图片，Base64 字符串的体积也要比二进制字节码的体积要大 1/3，这又进一步增加 Bundle 的大小。那为什么 Base64 转换后的体积，会比二进制的字节码的体积还要大 1/3 呢？这就要看下 Base64 图片的转换原理了。

我这里放了一张二进制图片转 Base64 图片的原理示意图，我们根据这张原理示意图来解释图片 Base64 后体积增加的原因。

<img src="tu9.png" style="zoom:80%;" />

首先，我们要树立两个基本认知。一是二进制图片不能直接以字符串形式存在 .js 文件中，因为直接用 ASCII （美国信息交换标准代码）表示的二进制字符串太大了。一个二进制 “00000000”，占 8 比特大小，也就是 1 个字节的大小。一个直接用 ASCII 表示的字符串 “00000000”，占 8*8 比特大小，也就是 8 个字节的大小，是二进制大小的 8 倍。

二是，二进制图片不能直接以 ASCII 的格式转换为字符串，这是因为 ASCII 字符集不仅存在可见字符，还存在不可见字符。例如，二进制 “00000000” 对应的 ASCII 字符是“空字符（Null）”，空字符是不可见字符。

但是，二进制图片可以借助 Base64 进行转换。Base64 从 ASCII 256 个字符中选取了 64 个可见字符作为基础，这样就二进制就能以 Base64 的格式转换为 ASCII 字符串了。例如，二进制 00000000 对应的 Base64 字符是 A，是可见字符，可见字符 A 是可以存在在 .js 文件中的。

需要注意的是，ASCII 256 个字符需要 8 个比特来表示（2^8=256），Base64 的 64 个字符只需要 6 个比特位来表示（2^6=64）。但实际上，Base64 字符也是以 ASCII 码的形式存在，因此这里就有 2 个比特的浪费（8-6=2）。

你可以再仔细观察一下前面我提供的 Base64 转换的原理示意图，相信你一下就能明白其中原理。Base64 以 3 个字节作为一组，一共是 24 比特。将这 24 个比特分成 4 个单元，每个单元 6 个比特。每个单元前面加 2 个 0 作为补位，一共 8 个比特，凑整 1 个字符。转换后原来的 24 比特，就变成了 32 比特，因此转换后的体积就大了 1/3（ 1/3 = 1 - 24/32）。

鉴于这样的情况，我的建议是** Base64 图片只适合用在体积小的图片或关键的图片上**。

### 最佳实践

看到这里，想必现在你已经对 4 类图片的使用场景，有一定的了解了。但是在具体实践中，我们应该怎么用呢？

现在我给你分享一下我的最佳实践，这套方案我也是在实践中，摸索了很久才得出的。这套最佳实践，适用于那些**将 React Native 当做一个动态更新框架来使用的应用**中。

首先是静态图片资源。如果你使用的是自研的热更新平台，就需要注意图片资源一定要先于 bundle 或和 bundle 一起下发，因为在执行 bundle 时，图片资源是必须已经存在的。

接着是网络图片和 Base64 图片。这两类图片之所以放在一起说，是因为它们单独管理起来都不方便，一张张手动上传网络图片不方便，一张张手动把图片 Base64 化也不方便，所以我们需要一个自动化的工具来管理它们。

比如，你可以把需要上传到网络的图片放在代码仓库的 assets/network 目录，把需要 Base64 化的图片放在 assets/base64 目录。

你在本地开发的时候，可以通过使用 require 静态图片资源的形式，引入 assets/network 或 assets/base64 目录中的图片来进行本地调试。在代码编译打包的时候，通过工具将 assets/network 目录中的图片上传到 CDN 上，将 assets/base64 目录中的图片都 Base64 化，并将 require 形式的静态图片资源代码转换为网络图片或 Base64 图片的代码。使用自动化工具来管理图片，代替人工手动管理，可以提高你的开发效率。

最后是宿主应用图片，这种加载图片的方式我不建议你使用，具体的原因我们前面已经分析过了。

我把这节课讲的这四种图片的使用总结成了这张图，你可以看看，加深一下印象：

![](tu10.png)

### 总结

今天的课程到这里就结束了，这里我再给你总结一下。

今天我们学习 React Native 中的图片组件 Image，了解了 4 种图片加载的方式和其最佳实践。

首先，发版更新的 React Native 应用，使用内置图片的最佳方式是静态图片资源，但对于动态更新的 React Native 应用而言，需要注意静态图片资源并不是真正的“内置”，而是必须和 Bundle 执行文件“同步”的加载。

然后，我推荐你自研一个图片管理工具，把设计师给你的图片管理起来，并按照指定的配置规则转换为 Base64 图片或网络图片，这样可以提高你的开发效率。

不过，React Native 复用宿主应用图片的这种方式，不推荐你使用。它有加载失败的风险，而且有较高的维护成本和沟通成本。

### 补充材料

1.   各类图片使用区别的 [React Native 中文网](https://reactnative.cn/docs/0.63/images)连接在这儿，你可以点击查看一下。
2.   React Native 框架对图片的默认缓存处理并不是最优的方案，社区中提供了替代方案 [FastImage](https://github.com/DylanVann/react-native-fast-image)，它是基于 SDWebImage (iOS) 和 Glide (Android) 实现的性能和效果会更好一些。

---
由于篇幅和Typora性能原因，剩下内容将再开一篇博客，***连接点我***。















